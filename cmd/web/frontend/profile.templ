package frontend

import (
	"fmt"
	"github.com/dimmerz92/go-lucide-icons/pkg/templ/icons"
	"videoapp/internal/generated/proto"
)

templ Profile(viewingUser *proto.User, videos []*proto.GetUserVideosResponseVideo, user *proto.UsersGetResponse) {
	<script>
		let toPoll = []
		function poll(id) {
		  console.log("Polling " + id)
  	  toPoll.push(id)
		}

		const refreshStagesId = setInterval(async () => {
		  if (toPoll.length == 0) {
	  	  console.log("Nothing to poll.")
    		clearInterval(refreshStagesId)
  		  return
  		}
	  	console.log("Refreshing stages")
			const res = await fetch("/stages", {
			  method: 'POST',
			  headers: {
		  	  'Content-Type': 'application/json'
			  },
				body: JSON.stringify(toPoll)
			})
			let json = await res.json()
			Alpine.store("stages", json)
		}, 15000)
		document.addEventListener("alpine:initializing", () => {
    	Alpine.store("stages", {})
		})
	</script>
	@AppLayout(viewingUser) {
		<div class="flex text-sm items-center gap-2">
			@Avatar(user.User.Id, "w-16")
			<div class="flex flex-col">
				<div class="font-bold text-lg leading-tight">
					if user.User.DisplayName == "" {
						{ "@" + user.User.Username }
					} else {
						{ user.User.DisplayName }
					}
				</div>
				<div class="flex gap-2 items-center">
					if user.User.DisplayName != "" {
						<span>{ "@" + user.User.Username }</span>
					}
					<button class="opacity-70 cursor-pointer hover:opacity-100" onclick="following.showModal()">{ formatCount(user.User.FollowingCount, "Following", false) }</button>
					<button class="opacity-70 cursor-pointer hover:opacity-100" onclick="followers.showModal()">{ formatCount(user.User.FollowerCount, "Follower", true) }</button>
				</div>
			</div>
			<!-- Hide option to follow yourself -->
			if viewingUser == nil || (viewingUser != nil && viewingUser.Id != user.User.Id) {
				if user.IsFollowing {
					@ButtonUnfollow(user.User.Id)
				} else {
					@ButtonFollow(user.User.Id)
				}
			}
		</div>
		<div class="text-sm opacity-90 whitespace-pre-wrap">
			{ user.User.Description }
		</div>
		<div role="tablist" class="tabs tabs-border">
			<a role="tab" class="tab tab-active">Videos</a>
			<a role="tab" class="tab">Playlists</a>
		</div>
		@ProfileVideoList(videos, viewingUser, user)
		<dialog id="following" class="modal">
			<div class="modal-box">
				<h3 class="text-lg font-bold">Following</h3>
				<p class="py-4">A list of people this user is following</p>
				<ul class="list bg-base-200 rounded-box">
					<div hx-get={ fmt.Sprintf("/user/%d/follows", user.User.Id) } hx-trigger="revealed" hx-swap="outerHTML"></div>
				</ul>
			</div>
			<form method="dialog" class="modal-backdrop">
				<button>close</button>
			</form>
		</dialog>
		<dialog id="followers" class="modal">
			<div class="modal-box max-h-3/4">
				<h3 class="text-lg font-bold">Followers</h3>
				<p class="py-4">A list of followers</p>
				<ul class="list bg-base-200 rounded-box">
					<div hx-get={ fmt.Sprintf("/user/%d/followers", user.User.Id) } hx-trigger="revealed" hx-swap="outerHTML"></div>
				</ul>
			</div>
			<form method="dialog" class="modal-backdrop">
				<button>close</button>
			</form>
		</dialog>
	}
}

templ ProfileVideoList(videos []*proto.GetUserVideosResponseVideo, viewingUser *proto.User, user *proto.UsersGetResponse) {
	<div class="gap-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 mt-1">
		for _, v := range videos {
			<div
				class="rounded-lg bg-base-200 transition shadow-none pb-4 hover:shadow-md"
			>
				{{
					flagged := v.Stage == proto.Stage_FlaggedForNudity
					notProcessed := !flagged && v.Stage != proto.Stage_Processed
					opacity := 0.0
					if notProcessed || flagged {
						opacity = 0.6
					}

					isFlaggedReactive := fmt.Sprintf("($store.stages['%d'] === %d)", v.Id, proto.Stage_FlaggedForNudity)
				}}
				@VideoLink(v.Id) {
					<div
						class={ "bg-base bg-cover bg-center aspect-video rounded-t-lg flex items-center justify-center ", BackgroundThumbnail(v.ThumbnailId) }
						style={ fmt.Sprintf("--opacity: %f", opacity) }
						if notProcessed {
							x-init={ fmt.Sprintf("poll('%d')", v.Id) }
							x-data
							x-bind:style={ fmt.Sprintf("$store.stages['%d'] !== %d ? { '--opacity': 0.6 } : { '--opacity': 0.0 }", v.Id, proto.Stage_Processed) }
						}
					>
						if notProcessed {
							// shows when flagged for nudity
							@icons.TriangleAlert(icons.IconProps{Class: "size-6", Attributes: templ.Attributes{"x-show": isFlaggedReactive}})
							// shows when not processed and not flagged for nudity
							@icons.Cog(icons.IconProps{Class: "size-6 animate-spin", Attributes: templ.Attributes{"x-show": fmt.Sprintf("!%s && $store.stages['%d'] !== %d", isFlaggedReactive, v.Id, proto.Stage_Processed)}})
						} else if flagged {
							@icons.TriangleAlert(icons.IconProps{Class: "size-6"})
						}
					</div>
				}
				<div class="px-4 pt-4 leading-none flex justify-between items-center">
					@VideoLink(v.Id) {
						<div class="tooltip w-full">
							<div class="tooltip-content wrap-anywhere z-50">
								{ v.Title }
							</div>
							<div class="max-w-full overflow-ellipsis overflow-hidden text-nowrap">{ v.Title }</div>
						</div>
						<div class="text-sm text-base-content/70">
							{ formatDate(v.CreatedAt) }
						</div>
					}
					<div>
						if viewingUser != nil && viewingUser.Id == user.User.Id {
							<a href={ fmt.Sprintf("/videos/%d/edit", v.Id) } class="btn btn-square">
								@icons.SquarePen(icons.IconProps{Class: "size-4"})
							</a>
						}
					</div>
				</div>
			</div>
		}
	</div>
}

css BackgroundThumbnail(id int64) {
	background-image: { templ.SafeCSSProperty(fmt.Sprintf("linear-gradient(rgba(0, 0, 0, var(--opacity)), rgba(0, 0, 0, var(--opacity))), url(\"%s/thumbnails/%d.webp\")", cfg.MediaAddress, id)) };
}

func formatCount(n int64, word string, pluralize bool) string {
	plural := word
	if pluralize {
		plural += "s"
	}

	switch {
	case n < 1000:
		if n == 1 {
			return fmt.Sprintf("1 %s", word)
		}
		return fmt.Sprintf("%d %s", n, plural)

	case n < 1_000_000:
		if n%1000 == 0 {
			return fmt.Sprintf("%dk %s", n/1000, plural)
		}
		return fmt.Sprintf("%.1fk %s", float64(n)/1000, plural)

	default:
		if n%1_000_000 == 0 {
			return fmt.Sprintf("%dM %s", n/1_000_000, plural)
		}
		return fmt.Sprintf("%.1fM %s", float64(n)/1_000_000, plural)
	}
}

templ FollowUserList(users *proto.FollowUsers, id int64, t string, page int) {
	if users != nil {
		for i, user := range users.Users {
			<a
				href={ fmt.Sprintf("/user/%s", user.Username) }
				if len(users.Users) - 1 == i {
					hx-get={ fmt.Sprintf("/user/%d/%s?page=%d", id, t, page) }
					hx-trigger="intersect once"
					hx-swap="afterend"
				}
			>
				<li class="list-row items-center gap-2">
					<div class="avatar size-8" x-data="{ image_found: true }">
						<div class="size-8 rounded-full bg-base-300 flex! items-center justify-center">
							<template x-if="image_found">
								<img
									id="avatar_preview"
									src={ fmt.Sprintf("%s/avatars/%d.webp", cfg.MediaAddress, user.UserId) }
									@error="image_found = false"
								/>
							</template>
							<template x-if="!image_found">
								@icons.UserRound(icons.IconProps{Class: "size-4"})
							</template>
						</div>
					</div>
					<div>
						{ user.Username }
						<div class="opacity-60 text-xs">{ formatDate(user.CreatedAt.Seconds) }</div>
					</div>
				</li>
			</a>
		}
	}
}
